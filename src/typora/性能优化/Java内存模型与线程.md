# Java内存模型与线程

## 为什么会有高并发？

- 由于计算机的CPU计算效率很高，但是对于其他资源，如磁盘的读写、网络通讯、数据库连接等等效率相对却低很多，所以导致了CPU需要等待其他资源处理，但是在等待期间，CPU完全可以去处理其他的事情，这时候就可以通过多个线程协助，合理利用好CPU的执行速度，从而提高程序的执行速度。
- 在Java作为服务器语言时，当多个客户端访问服务器时，通过让CPU对多个用户线程的并发执行，能够提高系统的并发量。

## 高并发带来的问题及解决办法

问题一：CPU计算速度和磁盘内存的读写速度相差太大，导致CPU计算需要等待磁盘的数据。

解决办法：给计算机引入高速缓存，以解决每次从内存读取数据太慢的问题。即每次先将CPU需要计算的数据通过内存复制高速缓存中，待计算完成后将数据同步到内存中。

问题二：由于引入了高速缓存，在多CPU的计算机中，多个CPU下的多个高速缓存同时操作一个数据时，将会出现缓存一致性的问题。

解决办法：Java在此基础之上定义了一个Java内存模型，以此来屏蔽掉各种硬件、操作系统的内存访问的差异、带来的问题（如缓存一致性），实现Java程序在各个平台各种不同硬件下的计算机达到一致的并发效果。

## Java内存模型

Java内存模型规定了所有的变量都存储在主内存中，每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写内存中的变量，不同的线程之间也不能直接访问对方工作内存中的变量，线程间变量值的传递都需要通过主内存来完成。

![image-20180830115102857](/var/folders/3m/lg512m_94_1d9ll7dh437_q00000gn/T/abnerworks.Typora/image-20180830115102857.png)



## 内存间的交互

一个线程需要使用一条数据的全过程：lock  -->  read  -->  load  -->  use  -->  assign  -->  store  -->  write

注意：如果要把一个变量从主内存复制到工作内存，必须按顺序执行read和load操作；如果要把变量从工作内存同步回主内存，必须按顺序执行store和write操作（但是不保证是连续执行，即只要保证从主内存复制到工作内存时需要先read之后才能load，即read需要在load之前，但是中间可以插入其他操作，例如read一个变量的同时也read另一个变量，把变量从工作内存写回到主内存也是一样的需要先store才能write）

Volatile变量



## Java与线程

- Java的线程通过直接映射到操作系统的内核线程上，然后由操作系统来完成线程的切换、调度和映射到各个处理器上
- Java调度线程（线程调度指系统为线程分配处理器使用权的过程）的方式为抢占式线程调度，即由操作系统来决定先执行哪个线程，执行的时间片为多少。







